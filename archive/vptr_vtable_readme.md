
# Understanding vptr and vtable in C++

This document explains the concepts of virtual pointers (vptr) and virtual tables (vtable) in C++ and how they are used by the compiler to support polymorphism, especially runtime polymorphism.

## Introduction

In C++, polymorphism is a core concept that allows objects of different classes to be treated as objects of a common base class. The most common type of polymorphism in C++ is achieved through virtual functions and inheritance.

## vptr (Virtual Pointer)

A virtual pointer, or vptr, is a pointer that is added by the compiler to classes which have virtual functions or are derived from classes with virtual functions. This pointer is used to access the virtual table of the class.

## vtable (Virtual Table)

A virtual table, or vtable, is a table generated by the compiler that contains pointers to the virtual functions of a class. Each class that has virtual functions or inherits such functions has its own vtable. The vtable is used at runtime to resolve function calls to the correct function implementations, based on the actual type of the object.

## How It Works

1. **Compile Time:** For each class with virtual functions (or inheriting them), the compiler generates a vtable. This table contains the addresses of the virtual functions of the class.

2. **Object Instantiation:** Objects of classes with virtual functions have a vptr that points to their class's vtable. If the object is of a derived class, its vtable will contain addresses to its overridden virtual functions.

3. **Runtime Function Call:** When a virtual function is called on a base class pointer (or reference) that points to a derived class object, the actual function called is determined at runtime through the following steps:
   - The program follows the object's vptr to access its vtable.
   - It looks up the function in the vtable to find the correct function to call. This allows the function call to be dynamically bound to the appropriate function implementation in the derived class, if it exists.

## Example

Assuming `Base` is a class with a virtual function `func()`, and `Derived` is a subclass that overrides `func()`:

```cpp
class Base {
public:
    virtual void func() {
        // Implementation for Base
    }
};

class Derived : public Base {
public:
    void func() override {
        // Implementation for Derived
    }
};

Base* base = new Derived;
base->func();  // Calls Derived::func() at runtime
```

This mechanism supports runtime polymorphism, enabling different behaviors for virtual function calls, depending on the actual type of the object.

